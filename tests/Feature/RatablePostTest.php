<?php

namespace Tests\Unit;

use App\Post;
use App\Rating;
use App\Trending;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Support\Facades\Redis;
use Tests\TestCase;

class RatablePostTest extends TestCase
{
    use RefreshDatabase;

    /** @var Trending */
    protected $trending;

    protected function setUp()
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        $this->trending = new Trending();
        $this->trending->reset();
    }

    /** @test */
    public function it_can_be_rated()
    {
        $post = create(Post::class);
        $rating = make(Rating::class, ['post_id' => $post->id]);

        $this->assertEquals(0, Rating::getQuery()->count());

        $this->postJson(route('ratable.store'), ['post_id' => $post->id, 'rating' => $rating->rating])
            ->assertStatus(200);

        $this->assertEquals(1, Rating::getQuery()->count());
        $this->assertDatabaseHas('ratings', ['post_id' => $post->id, 'rating' => $rating->rating]);
    }
    
    /** @test */
    public function it_should_return_average_value()
    {
        $post = create(Post::class);
        $rating = make(Rating::class, ['post_id' => $post->id]);

        $response = $this->postJson(route('ratable.store'), ['post_id' => $post->id, 'rating' => $rating->rating])
            ->assertStatus(200)
            ->json();

        $this->assertArraySubset(['average' => $rating->rating], $response);
    }

    /** @test */
    public function it_average_rating_should_be_correct_for_few_ratings()
    {
        $post = create(Post::class);
        /** @var Collection $ratings */
        $ratings = make(Rating::class, ['post_id' => $post->id], 3);

        $validAverage = round($ratings->pluck('rating')->avg(), 2);

        foreach ($ratings as $rating) {
            $response = $this->postJson(
                    route('ratable.store'), ['post_id' => $post->id, 'rating' => $rating->rating]
                )
                ->assertStatus(200)
                ->json();
        }

        $this->assertSame((double) $validAverage, (double) $response['average']);
    }

    /** @test */
    public function it_should_corrct_get_average_for_different_post()
    {
        create(Post::class, [], 2)->each(function(Post $post) {
            /** @var Collection $ratings */
            $ratings = make(Rating::class, ['post_id' => $post->id], 3);

            $validAverage = round($ratings->pluck('rating')->avg(), 2);

            foreach ($ratings as $rating) {
                $response = $this->postJson(
                    route('ratable.store'), ['post_id' => $post->id, 'rating' => $rating->rating]
                )
                    ->assertStatus(200)
                    ->json();
            }

            $this->assertSame((double) $validAverage, (double) $response['average']);
        });
    }

    /** @test */
    public function post_id_is_required()
    {
        $this->withExceptionHandling();

        $response = $this->postJson(route('ratable.store'), ['post_id' => null, 'rating' => 2])
            ->assertStatus(422)
            ->json();

        $this->assertArrayHasKey('errors', $response);
        $this->assertArrayHasKey('post_id', $response['errors']);
    }

    /** @test */
    public function post_id_must_be_is_of_created_post()
    {
        $this->withExceptionHandling();

        create(Post::class);
        $invalidId = 100;

        $response = $this->postJson(route('ratable.store'), ['post_id' => $invalidId, 'rating' => 2])
            ->assertStatus(422)
            ->json();

        $this->assertArrayHasKey('errors', $response);
        $this->assertArrayHasKey('post_id', $response['errors']);
    }
    
    /** @test */
    public function rating_is_required()
    {
        $this->withExceptionHandling();

        $post = create(Post::class);

        $response = $this->postJson(route('ratable.store'), ['post_id' => $post->id, 'rating' => null])
            ->assertStatus(422)
            ->json();

        $this->assertArrayHasKey('errors', $response);
        $this->assertArrayHasKey('rating', $response['errors']);
    }

    /** @test */
    public function rating_must_be_numeric()
    {
        $this->withExceptionHandling();

        $post = create(Post::class);

        $response = $this->postJson(route('ratable.store'), ['post_id' => $post->id, 'rating' => 'invalid'])
            ->assertStatus(422)
            ->json();

        $this->assertArrayHasKey('errors', $response);
        $this->assertArrayHasKey('rating', $response['errors']);
    }

    /**
     * @dataProvider ratingDataProvider
     * @test
     * @param $rating
     * @param $isValid
     */
    public function rating_value_must_be_between_1_and_5($rating, $isValid)
    {
        $this->withExceptionHandling();

        $post = create(Post::class);

        $response = $this->postJson(route('ratable.store'), ['post_id' => $post->id, 'rating' => $rating]);

        if( $isValid )
        {
            $response->assertStatus(200);
        }
        else
        {
            $response->assertStatus(422);

            $this->assertArrayHasKey('errors', $response->json());
            $this->assertArrayHasKey('rating', $response->json()['errors']);
        }
    }

    public function ratingDataProvider()
    {
        return [
            [-1, false],
            [0, false],
            [1, true],
            [2, true],
            [3, true],
            [4, true],
            [5, true],
            [6, false],
        ];
    }

    /** @test */
    public function after_adding_rating_it_should_add_post_with_score_to_redis_storage()
    {
        $post = create(Post::class);

        $this->assertSame(0, $this->trending->get()->count());

        $this->postJson(route('ratable.store'), ['post_id' => $post->id, 'rating' => 2]);

        $this->assertSame(1, $this->trending->get()->count());
        $this->assertEquals($post->id, $this->trending->get()[0]);
    }

    /** @test */
    public function rated_posts_sort_by_rating() :void
    {
        $post1 = create(Post::class);
        $this->postJson(route('ratable.store'), ['post_id' => $post1->id, 'rating' => 2]);

        $post2 = create(Post::class);
        $this->postJson(route('ratable.store'), ['post_id' => $post2->id, 'rating' => 5]);

        $this->assertSame(2, $this->trending->get()->count());
        $this->assertEquals($post2->id, $this->trending->get()[0]);
        $this->assertEquals($post1->id, $this->trending->get()[1]);
    }
}
